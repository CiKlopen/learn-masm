# assembly 学习记录

    1.机器语言
    2.编译器
    3.汇编语言
        汇编语言是机器语言的封装，有更好的助记符

# 各寄存器
    标志位寄存器  16位
        进位标志
        奇偶标志
        辅助进位标志
        零标志
        符号标志
        溢出标志
        方向标志
        中断允许标志
        陷阱标志
    段寄存器  CS ES SS DS
        CS      代码段寄存器
        ES      附加段寄存器
        SS      堆栈寄存器
        DS      数据段寄存器
    
    通用寄存器 AX BX CX DX  
        AX      累加器
        BX      基地址寄存器
        CX      计数寄存器
        DX      数据寄存器
    变址寄存器  SI DI
        SI      源索引
        DI      目的索引
    栈指针 SP BP
        SP      堆栈指针
        BP      基址指针
    指令指针 IP



# 基础
    1.2 汇编的产生
        程序员 ---- 汇编指令 ----- 编译器 ----- 机器码 ---- CPU
        CPU ----- 内存 ----- 外存 
        RAM ROM
    1.6 储存单元
        1byte = 8bit
        10的6次方 = 64
            7次方 = 128
            8次方 = 256
            10次方 = 1024
            16次方 = 65535
    1.7 CPU对储存器的读写  也就是对内存的的操作
            储存单元的地址（地址信息）
            器件的选择，读取或写入的命令 (控制信息)
            读或写的数据（数据信息）
    1.8 地址总线
            1.CPU是通过地址总线来指定储存器单元的。地址总线上能传送多少个不同的信息，CPU就可以对多少个存储单元进行寻址
            2.
    思考:
        为什么一个段最大为 64kb  
            因为8086的数据总线是，16位，但是它的地址总线为20位，正常来说，16位的限制使得寻址只能是2的16次方，
            也就是64kb，相对于1mb差了很多，我们想用更大的寻址空间。所以引入了段地址与偏移地址的概念，
            通过地址加法运算器，使得1mb寻址成为现实，1mb的寻址意味着更大的内存空间。
            要理解这个，必须要知道16进制，2进制，1mb寻址空间有16个64kb的段   
            16进制 
                    1 2 3 4 5 6 7 8 9 A B C D E F   16进1
            16X64 =1024 意味着 0000-0FFF 1000-1FFF A000-AFFF F000-FFF0 一个有16个段，每个段64kb
            0000 段大小 = 0FFF-OOOO = FFF x 16 = 65520  乘以16是为了得到十进制的65520 
            一个段，在没进入运算器之前是16位的，所以他只能是64kb，

        为什么最大寻址空间为 1mb
# 2023.12.29 学习记录" 基础
    
    1.控制指令 
        mov add
        指令例
            #        a         b
            # ax = 00000000  00000000
            # a  = ah  是高八位
            # b  = al  是低八位
        mov ax,bx   ax = bx
        mov ah,0    ah = 0       
        mov al,0    al = o
        mov ax,0    ax = 0
                    add ax,bx      ax = ax+bx
                    add al,0       al = al+0
                    add ah,0       ah = ah+0   



    2.寻址 (8086 CPU 16位寻址)
        寄存器  ax ah al  ah 是ax的高8位   al是低8位
                        bx bh bl  同上

    3.确定物理地址方法
            1.主储存器地址空间
            2.显存地址空间
            3.各类ROM地址空间
        CPU访问内存单元时要给出内存的地址
        所有的内存单元构成的储存空间是一个一维的线性空间

# 12.30  内存地址的计算
    
     8086 CPU  20位地址总线宽度  16位数据总线宽的
            两个16位地址（段地址）（偏移地址）合成一个20位的物理地址
     
     地址加法器合成物理地址的方法
            物理地址 = 段地址 X 16 + 偏移地址

#  12.31 debug
    debug
        -R 查看寄存器 CS:IP 指向的内存地址 修改寄存器的值
            -r ax 回车 可以修改ax寄存器中的值 同理 CS:IP中的值也可以修改
        -D 查看以CS:IP为起始地址的128字节内存中的
            可指定起始地址
            -d 1000:0 
            -d 1000:9 从9开始到 1000:88 128字节
            -d 1000:0 9 查看0-9的内存中的数据
        -e 修改内存中的值 
            -e 1000:0 48 48对应的ascii码为H
            -e 1000:0 48 45 4c 4c 4f 对应 HELLO  
        -e b8 01 00 b9 02 00 01 c8   
        -u    对应的汇编指令可以用 -U 查看
            修改内存中的值 为机器码
            -r CS
            -r IP
            -t 单步执行
            
        ##总结    
            -R 查看，修改CPU中寄存器的内容
            -D 查看内存中的内容
            -E 修改内存中的内容
            -U 将内存中的内容解释为机器指令和对应的汇编指令
            -T 执行CS:IP指向的内存单元处的指令
            -A 以汇编指令的形式向内存中写入指令 
# DS 段寄存器
        注意传入与被传入的数据大小关系
        mov al,bx       a的低八位或高八位，无法接收bx,此时bx是字类型寄存器，而al是独立的字节型寄存器
        mov bx,al  
        mov ax,1000:0   1000:0作为低八位，送入al，而1000:1，作为高八位送入ah，此时ax=al+ah
        ////
        mov ax,1000     将1000H 送入ax寄存器
        mov ds,ax       将ax寄存器的值送入ds段寄存器中

                        [...]表示一个内存单元
        
        mov [0],ax      [0] 是偏移地址  自动取段寄存器中的段进行组合   
                        可以看成 mov 1000:0,ax 将ax寄存器中的值 送入1000:0内存地址
        --------------
        mov ax,1000     这里是用段寄存器，将内存地址中的值送到al寄存器中
        mov ds,ax
        mov al,[0]
# mov add sub 指令
    mov 寄存器，数据
    mov 寄存器，寄存器
    mov 寄存器，内存单元
    mov 内存单元，寄存器
    mov 段寄存器，寄存器
    mov 段寄存器，内存单元
    mov 内存单元，段寄存器    
            
        注意 数据不能直接到段寄存器，需要数据寄存器中转。 
                 数据也不能直接送到内存单元，需要寄存器中转
    ## start
    ax = 2000
        
        sub ax,1000  等同 ax = ax -1000
    
        ax = 1000

        add ax，1000 等同 ax = ax + 1000
        
        ax = 2000
    ## end
    
    add sub 可以对段寄存器进行运算吗 答案是不可以 
# 数据段
    
    字在内存中的存储时，要用两个地址连续的内存单元来存放，字的低位字节存放在低地址单元中，高位字节存放在高地址单元中。
    
    用mov指令要访问内存单元，可以在mov指令中只给出单元的偏移地址，此时，段地址默认在DS寄存器中。
    
    address表示一个偏移地址为address的内存单元。
    
    在内存和寄存器之间传送字形数据时，高地址单元和高8位寄存器，低地址单元和低8位寄存器相对应。

    mov，add sub 是具有两个操作对象的指令。jmp是具有一个操作对象的指令

    可以根据自己的推测，在debug中的实验指令的新格式。

# 栈
    SS:SP指向栈顶元素
    SS:段寄存器
    SP:偏移地址寄存器
    
    
    栈的特性           后进先出 
             先进后出

        PUSH 入栈
        POP  出栈
    我的基本理解 栈是一种数据结构，可以通过CPU应用在内存中

    mov ax,0123H
    push ax
    mov bx,2266H
    push bx
    mov cx,1122H
    push cx
    pop ax
    pop bx
    pop cx

    问题。 变成，将10000H~1000FH这段空间当作栈，初始状态栈是空的，将ax，bx，ds中的数据入栈
        mov ax,1000
        mov ss,ax
        mov sp,0010H            为什么特意强调栈是空的，因为栈不为空的话，sp的指向可能有问题

        push ax
        push bx
        push ds
    

    实验 ax bx 数据交换

        mov ax,1000
        mov ss,ax
        mov sp,0010
        mov ax,001a
        mov bx,001b
        push ax
        push bx
        pop ax
        pop bx     栈中数据后入先出 完成数据的 交换   ax = 001b bx = 001a
    
    这里需要注意的是 ss:sp sp的指向问题，push前 sp=sp—2 所以，如果想ss:sp指向10000H  ss = 1000 sp = 0002
    执行push时 CPU的两步操作是；先改变sp，后向ss:sp处传送。执行pop时，先读取ss:sp处的数据，后改变sp
# 第一个程序
    
        ds 正段地址寄存器
        ex 副段地址寄存器
        cx loop指令循环寄存器次数
        loop指令 
            assume cs:code   指定代码起始地址段为code
            code segment
                dw 0123H,0456H,0789H,0ABCH,0DEFH,0FEDH,0CBAH,0987H 在代码段中定义数据

            start: mov bx,0     这里的start 是为了告诉编译器，cs:ip的指向位置  不能和上面的数据冲突
                    mov ax,0
                    mov cx,8

                    s: add bx,cs:[ax]     ############ 这里需要注意，段前缀知识点  ##########
                        add ax,2
                        loop s  循环标记s  从s处开始循环，先cx减一，再跳转到s处执行，减一为0时不执行
                    
                    mov ax,4c00h
                    int 21h
            code end
            end start

# 由源程序到目标程序

        先编译后连接
        指令为 masm 和 link


# 寻址方式 


# offset
    返回标号或变量的偏移地址

# jmp 无条件跳转指令  
        jmp short  短跳转
        jmp near ptr 近跳转
        jmp far ptr 远跳转
        短与近 是根据相对偏移量实现跳转  远跳转是绝对跳转 包含cs:ip

        寄存器 直接数 内存单元

# jcxz  cx寄存器等于zero  则跳转



# CALL AND ret   

    call o   // 执行call指令时 将cs:ip指向的地方入栈
    mov ax，4c00h
    int 21h

    o:
        ret  // ret 指令pop cs:ip 并返回

# 寄存器冲突
    
    注意 调用子程序 子程序的写法要先见将使用的寄存器压栈，ret前出栈，避免和其他程序寄存器冲突导致系统崩溃

# div 除法指令 

        mov ax，被除数
        mov bl，除数
        div bl

        8位 被除数放 ax寄存器  除数是操作数  商放 al  余数放ah
        16位 被除数放  dx与ax寄存器  dx是高16位 ax是低16位  商 ax  余数 bx
# dup  重复
    db dup 20 'a'  dup重复定义指令


# 标志寄存器
        CF 进位/借位标志位       有进位，1 无进位，0
        ZF 零位
# adc 带进位加法指令
    大数 a+b
    mov ax，低16位a
    mov bx, 低16位b
    add ax，bx  这里如果产生进位那么 cf标志位将为1
    mov dx，ax
    mov ax，高16位a
    mov bx，高16位b
    adc ax，bx

    此时 dx存放低16位  ax存放高16 
    
    
    adc ax，bx
    ax = ax + bx + CF

# sbb  带借位减法指令
    低16位的运算如果发生借位 那么高16位的运算将借位减去


    sbb ax，bx
    ax = ax - bx - CF


# cmp指令

    cmp ax，bx
    ax - bx   比较指令 功能相当于减法指令，不保存结果
    cmp 指令执行后，将对标志寄存器产生影响

    cmp ax,ax

    ZF=1  PF=1  SF   CF    OF = 0 
    零位  奇偶  符号  进位  溢出





    mov ax，8
    mov bx，3
    cmp ax，bx
    ax-bx = 5 仅对标志寄存器产生影响
    ZF=0  PF=1  SF   CF    OF = 0 
    零位  奇偶  符号  进位  溢出


    CMP可以运算比较关系
    无符号 主要看 CF ZF 两个标志位
    有符号 ZF SF OF 正负与溢出
    等于
    不等于
    小于
    大于
    大于等于
    小于等于

# 条件转移指令  
    利用标志寄存器里的标志位进行跳转转移

    je/jz       相等 结果为0            
    jne/jnz     不相等 结果不为零
    js          结果为负
    jns         结果非负
    jo          结果溢出
    jno         结果溢出
    jp          奇偶位为1
    jnp         奇偶位不为1
    jb/jnae/jc  低于  不高于等于 有错位
    jnb/jae/jnc 不低于  高于等于 无错位


# DF方向标志位 和串传送指令

    在串处理指令中，控制每次操作后si,di的增减
    DF=0 : 每次操作后si di      递增    cld
    DF=1 ：每次操作后si di      递减    std
    
    DF 区别在于在内存中是向前取数据 还是向后
    
    串传送指令
        movsb 字节   每次执行将ds:si处的一个字节  传送到es:di地址处
        movsw 字     每次执行将ds:si处的二个字节  传送到es:di地址处



    对DF位进行设置的指令
    
    cld指令  将标志寄存器的DF位设为0 clear
    std指令  将标志寄存器的DF位设为1 setup



# rep
    rep指令常和串传送指令搭配使用
    
    功能 ： 根据cx的值 ， 重复执行后面的指令
    用法 ： 
            
            db 16 dup  'abcde'
            mov cx,8
            rep movsb

# 移位指令
    在汇编语言中，
    移位指令用于将数据位在寄存器或内存位置中向左或向右移动一定数量的位。
    这些指令在位操作、数据编码、乘除运算优化等方面非常有用


    算数  1001 算术左移 0010  算数右移 1100
    循环  1001  循环左移 0011 循环右移1位 1100
    逻辑  
    带进位


    mov al,01010001b
    mov cl,3
    shl al,cl   cl的位置如果放立即数 只能放1
    这段代码的意思是 左移3位
    CF=0 10001000


# 操作显存数据
    不使用中断 通过修改显存来显示
    CPU --- 显存 --- 屏幕
    
    显存地址                        显存地址必须通过ES寄存器访问
        彩色显示的段地址 B800
        单色显示的段地址 B000
    字符和属性字节
        每个字符，两个字节构成，第一个字节是字符的ascii码，第二个字节是字符的显示属性(如颜色和亮度)
    
    写入字符和属性
        将每个字符的ASCII码及其属性字节依次写入 ES:0000 ES:0002 ES:0004  每个字符占用显存里的两个字节，所以地址是连续的

# 直接定址表

# 中断
    外部中断与 内部中断
    执行中断前 将标志寄存器 csip 各使用寄存器入栈
    中断完毕后 出栈继续执行

    根据中断号，去内存中 中断向量表00000-0003ff处查询中断程序入口地址，2个字的类型，保存的是cs:ip
    然后根据cs:ip去执行中断例程  中断例程执行完毕后 使用 IRET指令 从栈中恢复csip 标志寄存器的值 然后cpu根据csip继续向下执行


# 单步中断
    TF标志位 置1   标志寄存器只能通过 pushf popf 栈指令来修改
    pushf
    pop ax
    or ax，0100h
    push ax
    popf
    
    进入中断例程前 TF为1
    进入后 清楚TF的状态，这里是怕在执行中断例程的过程中，单步中断继续执行，形成死循环
    中断例程执行完毕后  IRET从栈中 恢复csip 标志寄存器
    然后根据csip继续执行，由于标志寄存器入栈前TF标志位为1，出栈后也为1，单步中断继续
    控制权交给dos

# int n 引起的中断
    1. 取中断类型码n
    2. 标志寄存器入栈，IF = 0 , TF = 0;
    3. CS,IP入栈；
    4. (IP) = (n*4),(CS) = (n*4+2)   // 根据中断类型码 加上这个算法，表示出存放中断程序入口地址的内存地址

# BIOS和dos中断例程
    bx dx ax 中存放参数 或 服务号
    int 中断号

    cpu加电 初始化cs = offff ip = 0
    初始化程序建立bios的中断向量表
    dos启动后建立它的中断向量表 以及将中断例程也加载到内存中

# 端口的读写
    各芯片工作时，都有一些寄存器，由CPU读写
    从CPU角度，将各寄存器当端口，并统一编址
    CPU用统一的方法与各种设备通信
    

    访问端口的方法
        例：in al，60h；从60h号端口读入一个字节

    执行时与总线相关的操作
        1. CPU通过地址线将地址信息60h发出
        2. CPU通过控制线发出端口读取命令，选中端口所在的芯片，并通知要从中读取数据；
        3. 端口所在的芯片将60h端口中的数据通过数据总线送入CPU
    
    
    访问外设 可以通过dos中断 bios中断  或者直接操作外设 
    in  CPU从端口读取数据
    
    out CPU往端口写入数据

    CPU可以直接读写的3个地方
    1.CPU内部的寄存器
    2.内存单元
    3.端口   -------------------------各种接口卡，网卡，显卡等
                                      主板上的接口芯片
                                      其他芯片
    对0-255以内的端口进行读写  端口号用立即数给出

    in al，20h  //从20h端口读入一个字节
    out 21h，al

    对256~65536的端口进行读写时，端口号放在dx中:

    mov dx,3f8h     将端口号 3f8送入dx
    in al,dx        从3f8h读入一个字节
    out dx,al       将al中的数据写入一个字节

    在in out 指令中，只能使用ax或al来存放从端口中读入的数据或要发送到端口中的数据。
    访问8位端口时用al，访问16位端口时用ax 
    123